
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pyepal.pal.core &#8212; pyepal v0.1.7+9.g7c57043.dirty documentation</title>

  <link rel="stylesheet" href="../../../_static/css/index.73d71520a4ca3b99cfee5594769eaaae.css">


  <link rel="stylesheet"
    href="../../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">



  <link rel="stylesheet"
    href="../../../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../../../_static/vendor/lato_latin-ext/1.44.1/index.css">


    <link rel="stylesheet" href="../../../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />

  <link rel="preload" as="script" href="../../../_static/js/index.3da636dd464baa7582d2.js">

    <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
    <script src="../../../_static/jquery.js"></script>
    <script src="../../../_static/underscore.js"></script>
    <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/language_data.js"></script>
    <script src="../../../_static/clipboard.min.js"></script>
    <script src="../../../_static/copybutton.js"></script>
    <script src="../../../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">


    <div class="container-xl">
      <div class="row">

<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">

        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../../../index.html">

  <img src="../../../_static/pyepal_logo.png" class="logo" alt="logo">


  <h1 class="site-logo" id="site-title">pyepal v0.1.7+9.g7c57043.dirty documentation</h1>

</a>
</div><form class="bd-search d-flex align-items-center" action="../../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="../../../getting_started.html">
   Getting Started
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../background.html">
   Background
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../tutorials.html">
   Tutorials
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../api.html">
   The PyePAL API reference
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../../../developer_notes.html">
   Developer notes
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Theme by the <a href="https://ebp.jupyterbook.org">Executable Book Project</a>
</div>

</div>






<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">

    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">

        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>


        <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        <a class="repository-button"
            href="https://github.com/kjappelbaum/pyepal"><button type="button" class="btn btn-secondary topbarbtn"
                data-toggle="tooltip" data-placement="left" title="Source repository"><i
                    class="fab fa-github"></i>repository</button></a>
        <a class="issues-button"
            href="https://github.com/kjappelbaum/pyepal/issues/new?title=Issue%20on%20page%20%2F_modules/pyepal/pal/core.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>

    </div>
</div>


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">

    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">

              <div>

  <h1>Source code for pyepal.pal.core</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="c1"># Copyright 2020 PyePAL authors</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#      http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>


<span class="sd">&quot;&quot;&quot;Core functions for PAL&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">jit</span>

<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">dominance_check_jitted_2</span><span class="p">,</span>
    <span class="n">dominance_check_jitted_3</span><span class="p">,</span>
    <span class="n">is_pareto_efficient</span><span class="p">,</span>
<span class="p">)</span>


<div class="viewcode-block" id="_get_uncertainty_region"><a class="viewcode-back" href="../../../api.html#pyepal.pal.core._get_uncertainty_region">[docs]</a><span class="k">def</span> <span class="nf">_get_uncertainty_region</span><span class="p">(</span>  <span class="c1"># pylint:disable=invalid-name</span>
    <span class="n">mu</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">std</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">beta_sqrt</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Args:</span>
<span class="sd">        mu (float): mean</span>
<span class="sd">        std (float): standard deviation</span>
<span class="sd">        beta_sqrt (float): scaling factor</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[float, float]: lower bound, upper bound</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">low_lim</span><span class="p">,</span> <span class="n">high_lim</span> <span class="o">=</span> <span class="n">mu</span> <span class="o">-</span> <span class="n">beta_sqrt</span> <span class="o">*</span> <span class="n">std</span><span class="p">,</span> <span class="n">mu</span> <span class="o">+</span> <span class="n">beta_sqrt</span> <span class="o">*</span> <span class="n">std</span>
    <span class="k">return</span> <span class="n">low_lim</span><span class="p">,</span> <span class="n">high_lim</span></div>


<div class="viewcode-block" id="_get_uncertainty_regions"><a class="viewcode-back" href="../../../api.html#pyepal.pal.core._get_uncertainty_regions">[docs]</a><span class="k">def</span> <span class="nf">_get_uncertainty_regions</span><span class="p">(</span>
    <span class="n">mus</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">stds</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">beta_sqrt</span><span class="p">:</span> <span class="nb">float</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the lower and upper bound of the uncertainty region</span>
<span class="sd">         for each dimension (=target)</span>

<span class="sd">    Args:</span>
<span class="sd">        mus (np.array): means</span>
<span class="sd">        stds (np.array): standard deviations</span>
<span class="sd">        beta_sqrt (float): scaling factors</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[np.array, np.array]: lower bounds, upper bounds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">low_lims</span><span class="p">,</span> <span class="n">high_lims</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mus</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">low_lim</span><span class="p">,</span> <span class="n">high_lim</span> <span class="o">=</span> <span class="n">_get_uncertainty_region</span><span class="p">(</span><span class="n">mus</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">stds</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">beta_sqrt</span><span class="p">)</span>
        <span class="n">low_lims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">low_lim</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">high_lims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">high_lim</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">low_lims</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">high_lims</span><span class="p">)</span></div>


<div class="viewcode-block" id="_union"><a class="viewcode-back" href="../../../api.html#pyepal.pal.core._union">[docs]</a><span class="k">def</span> <span class="nf">_union</span><span class="p">(</span>
    <span class="n">lows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">ups</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">new_lows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">new_ups</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Performing iterative intersection (eq. 6 in PAL paper) in all dimensions.</span>

<span class="sd">    Args:</span>
<span class="sd">        lows (np.array): lower bounds from previous iteration</span>
<span class="sd">        ups (np.array): upper bounds from previous iteration</span>
<span class="sd">        new_lows (np.array): lower bounds from current iteration</span>
<span class="sd">        new_ups (np.array): upper bounds from current iteration</span>

<span class="sd">    Returns:</span>
<span class="sd">        Union[np.array, np.array]: lower bounds, upper bounds</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out_lows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">out_ups</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">lows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="n">low</span><span class="p">,</span> <span class="n">up</span> <span class="o">=</span> <span class="n">_union_one_dim</span><span class="p">(</span>  <span class="c1"># pylint:disable=invalid-name</span>
            <span class="n">lows</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">ups</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">new_lows</span><span class="p">[:,</span> <span class="n">i</span><span class="p">],</span> <span class="n">new_ups</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">out_lows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">low</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">out_ups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">up</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">out_lows_array</span><span class="p">,</span> <span class="n">out_ups_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">out_lows</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">out_ups</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">out_lows_array</span><span class="p">,</span> <span class="n">out_ups_array</span></div>


<div class="viewcode-block" id="_union_one_dim"><a class="viewcode-back" href="../../../api.html#pyepal.pal.core._union_one_dim">[docs]</a><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_union_one_dim</span><span class="p">(</span>
    <span class="n">lows</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">ups</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">new_lows</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">new_ups</span><span class="p">:</span> <span class="n">Sequence</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Used to intersect the confidence regions, for eq. 6 of the PAL paper.</span>
<span class="sd">    The iterative intersection ensures that all uncertainty regions</span>
<span class="sd">    are non-increasing with t.</span>

<span class="sd">    We do not check for the ordering in this function.</span>
<span class="sd">    We really assume that the lower limits are the lower limits</span>
<span class="sd">    and the upper limits are the upper limits.</span>

<span class="sd">    All arrays must have the same length.</span>

<span class="sd">    Args:</span>
<span class="sd">        lows (Sequence): lower bounds from previous iteration</span>
<span class="sd">        ups (Sequence): upper bounds from previous iteration</span>
<span class="sd">        new_lows (Sequence): lower bounds from current iteration</span>
<span class="sd">        new_ups (Sequence): upper bounds from current iteration</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[np.array, np.array]: array of lower limits, array of upper limits</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out_lows</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">out_ups</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">low</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lows</span><span class="p">):</span>
        <span class="c1"># In one dimension we can imagine the following cases where there</span>
        <span class="c1"># is zero intersection</span>
        <span class="c1"># 1) |--old range--|   |--new range--|,</span>
        <span class="c1"># i.e., lower new limit above old upper limit</span>
        <span class="c1"># 2) |--new range--|   |--old range--|,</span>
        <span class="c1"># i.e., upper new limit below lower old limit</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">new_lows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ups</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">new_ups</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">low</span><span class="p">):</span>
            <span class="n">out_lows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_lows</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">out_ups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_ups</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

        <span class="c1"># In other cases, we want to intersect the ranges, i.e.</span>
        <span class="c1"># |---old range-|-|--new-range--| --&gt; |-|</span>
        <span class="c1"># i.e. we take the max of the lower limits and the min of the upper limits</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out_lows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">new_lows</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">out_ups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ups</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">new_ups</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_lows</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out_ups</span><span class="p">)</span></div>


<div class="viewcode-block" id="_pareto_classify"><a class="viewcode-back" href="../../../api.html#pyepal.pal.core._pareto_classify">[docs]</a><span class="k">def</span> <span class="nf">_pareto_classify</span><span class="p">(</span>  <span class="c1"># pylint:disable=too-many-arguments, too-many-locals</span>
    <span class="n">pareto_optimal_0</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">not_pareto_optimal_0</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">unclassified_0</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">rectangle_lows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">rectangle_ups</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">epsilon</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">]:</span>
    <span class="sd">&quot;&quot;&quot;Performs the classification part of the algorithm</span>
<span class="sd">    (p. 4 of the PAL paper, see algorithm 1/2 of the epsilon-PAL paper)</span>

<span class="sd">    One core concept is that once a point is classified,</span>
<span class="sd">    it does no longer change the class.</span>

<span class="sd">    When we do the comparison with +/- epsilon we always use the absolute values!</span>
<span class="sd">    Otherwise, we get inconcistent results depending on the sign!</span>

<span class="sd">    Args:</span>
<span class="sd">        pareto_optimal_0 (np.array): boolean mask of points classified as Pareto optimal</span>
<span class="sd">        not_pareto_optimal_0 (np.array): boolean mask of points</span>
<span class="sd">            classified as non-Pareto optimal</span>
<span class="sd">        unclassified_0 (np.array): boolean mask of unclassified points</span>
<span class="sd">        rectangle_lows (np.array): lower uncertainty boundaries</span>
<span class="sd">        rectangle_ups (np.array): upper uncertainty boundaries</span>
<span class="sd">        epsilon (np.array): granularity parameter (one per dimension)</span>

<span class="sd">    Returns:</span>
<span class="sd">        Tuple[list, list, list]: binary encoded list of Pareto optimal,</span>
<span class="sd">            non-Pareto optimal and unclassified points</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pareto_optimal_t</span> <span class="o">=</span> <span class="n">pareto_optimal_0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">not_pareto_optimal_t</span> <span class="o">=</span> <span class="n">not_pareto_optimal_0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">unclassified_t</span> <span class="o">=</span> <span class="n">unclassified_0</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># This part is only relevant when we have points in set P</span>
    <span class="c1"># Then we can use those points to discard points from p_pess (P \cup U)</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">pareto_optimal_0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">pareto_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pareto_optimal_0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pareto_pessimistic_lows</span> <span class="o">=</span> <span class="n">rectangle_lows</span><span class="p">[</span><span class="n">pareto_indices</span><span class="p">]</span>  <span class="c1"># p_pess(P)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unclassified_0</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">unclassified_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># discard if any lower-bound epsilon dominates the upper bound</span>
                <span class="k">if</span> <span class="n">dominance_check_jitted_2</span><span class="p">(</span>
                    <span class="n">pareto_pessimistic_lows</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">epsilon</span> <span class="o">*</span> <span class="n">pareto_pessimistic_lows</span><span class="p">),</span>
                    <span class="n">rectangle_ups</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
                <span class="p">):</span>
                    <span class="n">not_pareto_optimal_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="n">unclassified_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="n">pareto_unclassified_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">pareto_optimal_0</span> <span class="o">|</span> <span class="n">unclassified_t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">pareto_unclassified_lows</span> <span class="o">=</span> <span class="n">rectangle_lows</span><span class="p">[</span><span class="n">pareto_unclassified_indices</span><span class="p">]</span>

    <span class="c1"># assuming maximization</span>
    <span class="n">pareto_unclassified_pessimistic_mask</span> <span class="o">=</span> <span class="n">is_pareto_efficient</span><span class="p">(</span>
        <span class="o">-</span><span class="n">pareto_unclassified_lows</span>
    <span class="p">)</span>
    <span class="n">original_indices</span> <span class="o">=</span> <span class="n">pareto_unclassified_indices</span><span class="p">[</span><span class="n">pareto_unclassified_pessimistic_mask</span><span class="p">]</span>
    <span class="n">pareto_unclassified_pessimistic_points</span> <span class="o">=</span> <span class="n">pareto_unclassified_lows</span><span class="p">[</span>
        <span class="n">pareto_unclassified_pessimistic_mask</span>
    <span class="p">]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unclassified_t</span><span class="p">)):</span>  <span class="c1"># pylint:disable=consider-using-enumerate</span>
        <span class="c1"># We can only discard points that are unclassified so far</span>
        <span class="c1"># We cannot discard points that are part of p_pess(P \cup U)</span>
        <span class="k">if</span> <span class="n">unclassified_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">original_indices</span><span class="p">):</span>
            <span class="c1"># discard if any lower-bound epsilon dominates the upper bound</span>
            <span class="k">if</span> <span class="n">dominance_check_jitted_2</span><span class="p">(</span>
                <span class="n">epsilon</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">pareto_unclassified_pessimistic_points</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">pareto_unclassified_pessimistic_points</span><span class="p">,</span>
                <span class="n">rectangle_ups</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="p">):</span>
                <span class="n">not_pareto_optimal_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">unclassified_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># now, update the pareto set</span>
    <span class="c1"># if there is no other point x&#39; such that max(Rt(x&#39;)) &gt;= min(Rt(x))</span>
    <span class="c1"># move x to Pareto</span>
    <span class="n">unclassified_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">unclassified_t</span> <span class="o">|</span> <span class="n">pareto_optimal_t</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">unclassified_ups</span> <span class="o">=</span> <span class="n">rectangle_ups</span><span class="p">[</span><span class="n">unclassified_indices</span><span class="p">]</span>

    <span class="n">index_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">index</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">unclassified_indices</span><span class="p">)}</span>

    <span class="c1"># The index map helps us to mask the current point from the unclassified_ups list</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unclassified_t</span><span class="p">)):</span>  <span class="c1"># pylint:disable=consider-using-enumerate</span>
        <span class="c1"># again, we only care about unclassified points</span>
        <span class="k">if</span> <span class="n">unclassified_t</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="c1"># If there is no other point which up is epsilon dominating</span>
            <span class="c1"># the low of the current point,</span>
            <span class="c1"># the current point is epsilon-accurate Pareto optimal</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dominance_check_jitted_3</span><span class="p">(</span>
                <span class="n">unclassified_ups</span><span class="p">,</span>
                <span class="n">rectangle_lows</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">epsilon</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">rectangle_lows</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                <span class="n">index_map</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
            <span class="p">):</span>
                <span class="n">pareto_optimal_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">unclassified_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="n">pareto_optimal_t</span><span class="p">,</span> <span class="n">not_pareto_optimal_t</span><span class="p">,</span> <span class="n">unclassified_t</span></div>


<span class="c1"># ToDo: maybe add jitter to avoid issues when the prediction is exactly 0</span>
<div class="viewcode-block" id="_get_max_wt"><a class="viewcode-back" href="../../../api.html#pyepal.pal.core._get_max_wt">[docs]</a><span class="nd">@jit</span><span class="p">(</span><span class="n">nopython</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">_get_max_wt</span><span class="p">(</span>  <span class="c1"># pylint:disable=too-many-arguments</span>
    <span class="n">rectangle_lows</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">rectangle_ups</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">means</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">pareto_optimal_t</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">unclassified_t</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
    <span class="n">sampled</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;Returns the index in design space with the maximum size of the hyperrectangle</span>
<span class="sd">    (scaled by the mean predictions, i.e., effectively,</span>
<span class="sd">    we use the coefficient of variation).</span>
<span class="sd">    Samples only from unclassified or Pareto-optimal points.</span>

<span class="sd">    Args:</span>
<span class="sd">        rectangle_lows (np.array): Lower, pessimistic, bounds of the hyperrectangles</span>
<span class="sd">        rectangle_ups (np.array): Upper, optimistic, bounds of the hyperrectangles</span>
<span class="sd">        means (np.array): Mean predictions</span>
<span class="sd">        pareto_optimal_t (np.array): Mask array that is True</span>
<span class="sd">            for the Pareto optimal points</span>
<span class="sd">        unclassified_t (np.array): Mask array that is True for the unclassified points</span>
<span class="sd">        sampled (np.array): Mask array that is True for the sampled points</span>

<span class="sd">    Returns:</span>
<span class="sd">        int: index with maximum size of hyperrectangle</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">max_uncertainty</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="n">maxid</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unclassified_t</span><span class="p">)):</span>  <span class="c1"># pylint:disable=consider-using-enumerate</span>
        <span class="c1"># Among the points x ∈ Pt ∪ Ut, the one with the largest wt(x)</span>
        <span class="c1"># is chosen as the next sample xt to be evaluated.</span>
        <span class="c1"># Intuitively, this rule biases the sampling towards exploring,</span>
        <span class="c1"># and thus improving the model for, the points most likely to be Pareto-optimal.</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">unclassified_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">pareto_optimal_t</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">))</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sampled</span><span class="p">[</span>
            <span class="n">i</span>
        <span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># weight is the length of the diagonal of the uncertainty region</span>
            <span class="n">coeff_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span>
                <span class="n">rectangle_ups</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">rectangle_lows</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">means</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span>
            <span class="p">)</span>
            <span class="n">uncertainty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coeff_var</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">uncertainty</span> <span class="o">&gt;</span> <span class="n">max_uncertainty</span><span class="p">:</span>
                <span class="n">max_uncertainty</span> <span class="o">=</span> <span class="n">uncertainty</span>
                <span class="n">maxid</span> <span class="o">=</span> <span class="n">i</span>

    <span class="k">return</span> <span class="n">maxid</span></div>


<div class="viewcode-block" id="_uncertainty"><a class="viewcode-back" href="../../../api.html#pyepal.pal.core._uncertainty">[docs]</a><span class="k">def</span> <span class="nf">_uncertainty</span><span class="p">(</span><span class="n">rectangle_ups</span><span class="p">,</span> <span class="n">rectangle_lows</span><span class="p">,</span> <span class="n">means</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Hyperrectangle sizes&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">rectangle_lows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">rectangle_ups</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;You must have trained a model and</span><span class="se">\</span>
<span class="s2">             run the prediction to calculate hyperrectangle&quot;</span>
        <span class="p">)</span>
    <span class="n">coeff_var</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="n">rectangle_ups</span> <span class="o">-</span> <span class="n">rectangle_lows</span><span class="p">,</span> <span class="n">means</span><span class="p">))</span>
    <span class="n">uncertainty</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">coeff_var</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">uncertainty</span></div>
</pre></div>

              </div>

        </div>
    </div>


    <div class='prev-next-bottom'>


    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>

          By Kevin Maik Jablonka, Brian Yoo, Berend Smit<br/>

            &copy; Copyright 2020, Kevin Maik Jablonka, Brian Yoo, Berend Smit.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>


  <script src="../../../_static/js/index.3da636dd464baa7582d2.js"></script>



  </body>
</html>
